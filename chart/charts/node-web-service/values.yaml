# Helm 3 dependencies have some really weird behavior that doesn't seem to
# match the docs when you ahve subcharts and aliases. This is the only way I
# can get it to work, by having exactly `alias.enabled` set to a boolean value.
database:
  enabled: true

cache:
  enabled: false
  purpose: cache
  maxmemoryPolicy: "allkeys-lfu"

# users deploying subcharts are expected to pass:
#   * image.tag - any valid Docker tag, e.g. v1.2.3 or my-branch-123abc
#
#   * configuration - the name of a valid configuration from the below values.
#   `production` is computed if not defined. This isn't necessarily identical
#   to the environment name, as you may have several identical non-production
#   environments that share the same configuration to allow several staging
#   environments
#
#   * environment - (required only for isInternetFacing services) the name of
#   the environment, e.g. integrations-staging. If in doubt, you can inspect
#   ConfigMap default/environment-info:
#   kubectl get cm environment-info -ojson | jq ".data.project_name"
image:
  # Docker Image name, e.g. g5search/my-app-name
  name: ""

# Determines whether the service should be configured with external DNS and an
# Internet-facing load balancer. If your service is only used within the G5
# cluster, seriously consider not making it publicly accessible on the
# Internet!
isInternetFacing: false

# Whether the app uses an Ingress. If true, DNS records will use the ingress IP. 
# If false, DNS will use the virtualservice IP.
hasIngress: false

# This allows an app to opt out of the automatic DNS record creation provided by external-dns.
hasExternalDns: true

# Force HTTP traffic to HTTPS during ingress. Does not apply to in-cluster
# service-to-service traffic
forceSSLRedirect: true

configurations:
  # `production` is a reserved environment name. If all of your values are
  # typical (no special production-only sidekiq-cron jobs, lives at
  # app-name.g5marketingcloud.com, etc) then you may be able to skip defining
  # it and rely on default computed values. Any environment not named
  # `production` will automatically get non-production defaults, so you may not
  # need to define any of your environments if they all hold identical
  # configuration and work with defaults for hostnames and other values.
  #
  # You can use YAML's built-in inheritence to limit duplication, as shown
  # below with the `common` section.  You don't need to use this technique for
  # setting environment variables identically across all environments, as you
  # can just hardcode the value of the variable in the `env` section of this
  # file. For other cases, like multiple non-production environments using a
  # similar set of values, inheritence can be used. This can be applied
  # anywhere, including for configMapData and sidekiqCronSchedule.
  #_common: &common
  #  sample_common_value: "foo"
  #production:
  #  publicHostname: ""
  #  # You can remove this line if the defaults suit you
  #  istioGateway: ""
  #  configMapData:
  #    <<: *common
  #    sample_unique_value: "bar"
  #  # Sidekiq cron schedule file, if sidekiq workers are present. Don't forget the
  #  # `|-`. In the context of a ConfigMap key, this is really just a multiline
  #  # string that happens to be YAML content.
  #  sidekiqCronSchedule: |-
  #    my_cool_job:
  #      cron: "* 10 * * * America/Los_Angeles"
  #      class: "SomeClass"
  #      name: "A helpful description"
  #nonproduction:
  #  # false is the default, but can be set to true to not downscale Rails in
  #  # non-production environments.
  #  dontDownscaleRails: false
  #  # identical to dontDownscaleRails, but for all sidekiq-related deployments.
  #  dontDownscaleSidekiq: false
  #  publicHostname: ""
  #  # You can remove this line if the defaults suit you
  #  istioGateway: ""
  #  configMapData:
  #    <<: *common
  #    sample_unique_value: "baz"
  #  # environments with no sidekiqCronSchedule should use a blank string for
  #  # the value. *Something* needs to be written to disk or sidekiq's
  #  # initializer will explode.
  #  sidekiqCronSchedule: ""
  #  # environments with g5AuthEndpoint can set a custom G5 auth endpoint.
  #  # The default endpoint is https://auth.g5search.com.
  #  g5AuthEndpoint: "https://auth-staging.example.com"
  #  # environments with hubURL can set a custom HUB_URL, which is used by
  #  # g5-updatable to override the Hub this app should communicate with. If you
  #  # don't override the value, we don't set an environment variable.
  #  hubURL: "https://hub.example.com"

# Default values for imagePullSecrets.
imagePullSecrets:
  - name: gcsr-service-account

# Override automatically generated Scout APM App Name
scoutAppName: ""

# Sets Honeybadger-related environment variables to allow exception reporting.
# This will only do anything if the `honeybadger` gem is present in the
# Gemfile. You may be thinking this token is a secret, and you're right, but
# it's the same across every installation of the project and it's the least
# secret secret ever. It can only be used to post fake exceptions, which would
# be more hilarious than anything else.
# honeybadgerAPIKey: ""

#features:
#  # sets Scout APM configuring environment variables
#  - "scout"
#  # LEGACY auth-related environment variables for apps that require browser login
#  - "g5-auth-oauth-app"
#  # LEGACY auth-related environment variables for service-to-service calls originating
#  # from this app
#  - "g5-auth-service-to-service-client"

volumes: {}

# Node server deployment
# default horizontal scaling count
replicas: 2
# Thread count for Rails server
concurrency: 5
# Container start command
command:
  - npm
  - start
# Disable probes. Don't do this except for troubleshooting non-production,
# because it will break graceful deployments, amongst many other things.
disableHealthChecking: false
# Subcharts *must* define resources!
#resources:
# optional, causes the Rails servers to run on preemptible nodes. I wouldn't
# use this on a client-facing app
#toleratesPreemptible: true
# optional, if you toleratesPreemptible you can also require that your pods
# go on preemptible nodes. The default is for them to *prefer* preemptible
# nodes. The default allows for your pods to go on more expensive nodes if
# there is an issue with the preemptible instances. Setting this to true
# means it will always be cheaper but may be slightly less reliable
#requiresPreemptible: true
# optional, creates an HPA. Note that the replicas value in the worker
# needs to fall in the min/max range or you are going to have a bad
# time. Deployment and HPA will fight each other.
#autoscaling:
#  minReplicas: 1
#  maxReplicas: 2
#  targetCPUUtilizationPercentage: 66

# Environment variables in normal Kubernetes pod spec format.
#env:
#  - name: FOO
#    value: "bar"

# Setting this flag will restart all the Deployments by adding an annotation
# with a random number to the pod template. ConfigMap changes will
# automatically roll the pods, so I can't think of a great reason to do this,
# but I'm including it.
forceRestart: false

pubsubSubscriber:
  perSubscriptionConcurrency: 2
  # Just use the default unless your app requires more resources
  resources:
    requests:
      memory: "512Mi"
      cpu: "50m"
    limits:
      memory: "512Mi"
      cpu: "500m"
  # Both of these are good defaults, but might need to be overridden if you
  # have a more critical Pub/Sub subscription that has good reason to minimize
  # disruption.
  toleratesPreemptible: true
  replicas: 1
  strategy:
    type: Recreate

# This is how GKE Node Auto-provisioning works, if you require a node with this
# taint it will create it and make it preemptible. It's a special reserved
# term. I don't think you want to override this.
preemptibleTaint: "cloud.google.com/gke-preemptible"

# These can be used in cases where we are transitioning from one database/cache
# to another for some reason (like a Postgres upgrade, for instance) and need
# to run both in parallel. These controls which instance that Rails will be
# configured to connect to. By default, it will be the one that
# `node-web-service` brings in.
activeCloudSQLSubchart: "cloud-sql"
activeCacheSubchart: "cache"

auth0:
  client:
    create: false
    # Can override this if you're positive that this application never needs a
    # browser login.
    machineToMachineOnly: false
    # This name will show up in browser logins anyone will see when logging
    # into an application. It will also show up in the Auth0 Management web UI.
    # If your application has an unusual or user-unfriendly name (e.g. imc),
    # set this.
    friendlyName: ""
    # Can override this to cause this Auth0 Client to be linked to the Database
    # that our customer logins are stored. Not applicable when
    # machineToMachineOnly is true.
    allowsCustomerLogin: false
    # Default for allowing unified-login services
    allowUnifiedLogin: false
    # An array of other logout urls
    otherLogOutUrls: false
    # You probably shouldn't override this, but it is a list of all the ports
    # that staging and auth-staging tenant applications will get added to their
    # callbacks, to facilitate local testing.
    localhostPorts:
      - 3000
      - 3001
      - 3002
      - 3003
      - 3004
      - 3005
      - 3006
      - 3007
      - 3008
      - 3009
  resourceServer:
    create: false
    # These are required if create is true. There is no point having a
    # ResourceServer that has no Client Grants. This should be an array of
    # application names, and those names *MUST* match the DevOps official
    # application name. The application does not need to be in this cluster,
    # but this can only grant access to other applications within the same
    # tenant.
    allowedApplications: []
    # Should be an array of objects with a name and a scopes field,
    # where name is a string and scopes is an array of strings that
    # must be valid scopes on the resource server.
    scopedApplications: []
